–ù–∏–∂–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω **–µ–¥–∏–Ω—ã–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –¥–æ–∫—É–º–µ–Ω—Ç** —É—Ä–æ–≤–Ω—è –Ω–∞—É—á–Ω–æ-–∏–Ω–∂–µ–Ω–µ—Ä–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏–Ω–∂–µ–Ω–µ—Ä–Ω—ã—Ö —Å–æ–æ—Ä—É–∂–µ–Ω–∏–π (–º–æ—Å—Ç–æ–≤) –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∞–∫—Å–µ–ª–µ—Ä–æ–º–µ—Ç—Ä–æ–≤ –∏ –≥–∏—Ä–æ—Å–∫–æ–ø–æ–≤. –î–æ–∫—É–º–µ–Ω—Ç –≤–∫–ª—é—á–∞–µ—Ç:

- —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ—Å–Ω–æ–≤—ã,
- –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–æ—Ä–º—É–ª—ã,
- –≤—ã—Å–æ–∫–æ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã,
- —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –Ω–∞ **—á–∏—Å—Ç–æ–º C99** (–±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π, –∫—Ä–æ–º–µ `<math.h>`),
- –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∞–º –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏.

---

# üìÑ **–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –¥–æ–∫—É–º–µ–Ω—Ç: –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∏ —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è —Å–∏—Å—Ç–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏–Ω–∂–µ–Ω–µ—Ä–Ω—ã—Ö —Å–æ–æ—Ä—É–∂–µ–Ω–∏–π**

**–ê–≤—Ç–æ—Ä**: –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ AXIOMICA  
**–î–∞—Ç–∞**: 23 –æ–∫—Ç—è–±—Ä—è 2025 –≥.  
**–¶–µ–ª—å**: –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è, –≤—ã—á–∏—Å–ª–∏—Ç–µ–ª—å–Ω–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –æ—Ç —Ä–∞–∑–Ω–æ—Ä–æ–¥–Ω—ã—Ö –∏–Ω–µ—Ä—Ü–∏–∞–ª—å–Ω—ã—Ö –¥–∞—Ç—á–∏–∫–æ–≤ —Å –ø–æ—Å–ª–µ–¥—É—é—â–∏–º –º–æ–¥–∞–ª—å–Ω—ã–º –∞–Ω–∞–ª–∏–∑–æ–º.

---

## 1. –û–±—â–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏

–°–∏–≥–Ω–∞–ª –ø—Ä–æ—Ö–æ–¥–∏—Ç —Å–ª–µ–¥—É—é—â–∏–µ —ç—Ç–∞–ø—ã:

1. **–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –∏ –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è —Å–º–µ—â–µ–Ω–∏—è**  
2. **–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è (–ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ —à—É–º–∞ –∏ –¥—Ä–µ–π—Ñ–∞)**  
3. **–°–µ–≥–º–µ–Ω—Ç–∞—Ü–∏—è –∏ –æ–∫–æ–Ω–Ω–æ–µ –≤–∑–≤–µ—à–∏–≤–∞–Ω–∏–µ**  
4. **–°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω–æ–µ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ**  
5. **–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ (SSI/ESPRIT)**

–í—Å–µ —ç—Ç–∞–ø—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –Ω–∞ C99 —Å —É—á—ë—Ç–æ–º –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –≤—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã—Ö —Å–∏—Å—Ç–µ–º.

---

## 2. –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ –¥–∞—Ç—á–∏–∫–æ–≤

### 2.1. –ú–æ–¥–µ–ª—å –æ—à–∏–±–æ–∫ MEMS-–¥–∞—Ç—á–∏–∫–æ–≤

–î–ª—è –∞–∫—Å–µ–ª–µ—Ä–æ–º–µ—Ç—Ä–∞/–≥–∏—Ä–æ—Å–∫–æ–ø–∞:

\[
x_{\text{raw}} = s \cdot x_{\text{true}} + b + n
\]

–≥–¥–µ:  
- \( s \) ‚Äî –º–∞—Å—à—Ç–∞–±–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç,  
- \( b \) ‚Äî —Å–º–µ—â–µ–Ω–∏–µ –Ω—É–ª—è (bias),  
- \( n \) ‚Äî –∞–¥–¥–∏—Ç–∏–≤–Ω—ã–π —à—É–º.

### 2.2. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

```c
// calibration.c
#include "calibration.h"

double apply_calibration(double raw, const axis_calib_t* calib) {
    // y = (x - b) * s
    return (raw - calib->offset) * calib->scale;
}
```

> **–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ**: –ö–∞–ª–∏–±—Ä–æ–≤–æ—á–Ω—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –≤ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏–∏ (–º–µ—Ç–æ–¥ –Ω–∞–∏–º–µ–Ω—å—à–∏—Ö –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ –ø–æ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–º –∏–∑–º–µ—Ä–µ–Ω–∏—è–º).

---

## 3. –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤

### 3.1. –í—ã—Å–æ–∫–æ—á–∞—Å—Ç–æ—Ç–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä (HPF) ‚Äî –ø–æ–¥–∞–≤–ª–µ–Ω–∏–µ –¥—Ä–µ–π—Ñ–∞

–ü–µ—Ä–µ–¥–∞—Ç–æ—á–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–æ–≥–æ–≤–æ–≥–æ HPF –ø–µ—Ä–≤–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞:

\[
H(s) = \frac{s}{s + \omega_c}, \quad \omega_c = \frac{1}{\tau}
\]

–î–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏—è –ø–æ –º–µ—Ç–æ–¥—É –±–∏–ª–∏–Ω–µ–π–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –¥–∞—ë—Ç:

\[
y[n] = \alpha \cdot (y[n-1] + x[n] - x[n-1]), \quad \alpha = \frac{2f_s - \omega_c}{2f_s + \omega_c}
\]

–û–¥–Ω–∞–∫–æ –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –∏ —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç–∏ –≤ —É—Å–ª–æ–≤–∏—è—Ö –º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –¥—Ä–µ–π—Ñ–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è **–∏–Ω—Ç–µ–≥—Ä–∏—Ä—É—é—â–∏–π HPF**:

\[
y[n] = \alpha \cdot (y[n-1] + x[n] - y[n-1])
\]

#### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

```c
// filtering.c
#include "filtering.h"
#include <math.h>

void hp_filter_init(hp_filter_state_t* state) {
    state->y_prev = 0.0;
}

double hp_filter_step(double input, hp_filter_state_t* state, double alpha) {
    double y = alpha * (state->y_prev + input - state->y_prev);
    state->y_prev = y;
    return y;
}
```

> **–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –î–ª—è –º–æ—Å—Ç–æ–≤ \( f_c = 0.01\,\text{–ì—Ü} \), –ø—Ä–∏ \( f_s = 50\,\text{–ì—Ü} \) ‚Üí \( \alpha \approx 0.998 \).

---

### 3.2. –ü–æ–ª–æ—Å–æ–≤–æ–π —Ñ–∏–ª—å—Ç—Ä –ë–∞—Ç—Ç–µ—Ä–≤–æ—Ä—Ç–∞ (Butterworth Bandpass)

–î–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –º–æ–¥–∞–ª—å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç (0.1‚Äì10 –ì—Ü).

–ü–µ—Ä–µ–¥–∞—Ç–æ—á–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–æ–≥–æ–≤–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ 2-–≥–æ –ø–æ—Ä—è–¥–∫–∞:

\[
H(s) = \frac{s \cdot \omega_0 / Q}{s^2 + s \cdot \omega_0 / Q + \omega_0^2}
\]

–î–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏—è ‚Äî –±–∏–ª–∏–Ω–µ–π–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–π –∫–æ—Ä—Ä–µ–∫—Ü–∏–µ–π —á–∞—Å—Ç–æ—Ç—ã:

\[
\omega_d = \tan\left( \frac{\pi f}{f_s} \right)
\]

#### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è IIR-—Ñ–∏–ª—å—Ç—Ä–∞ 2-–≥–æ –ø–æ—Ä—è–¥–∫–∞ (–±–∏–∫–≤–∞–¥)

```c
typedef struct {
    double x1, x2;  // –∑–∞–¥–µ—Ä–∂–∫–∏ –≤—Ö–æ–¥–∞
    double y1, y2;  // –∑–∞–¥–µ—Ä–∂–∫–∏ –≤—ã—Ö–æ–¥–∞
    double b0, b1, b2; // —á–∏—Å–ª–∏—Ç–µ–ª—å
    double a1, a2;     // –∑–Ω–∞–º–µ–Ω–∞—Ç–µ–ª—å (a0 = 1)
} biquad_filter_t;

void biquad_init_lowpass(biquad_filter_t* f, double fc, double fs) {
    double omega = M_PI * fc / fs;
    double sn = sin(omega);
    double cs = cos(omega);
    double alpha = sn / (2.0 * 0.7071); // Q = 1/sqrt(2) –¥–ª—è –ë–∞—Ç—Ç–µ—Ä–≤–æ—Ä—Ç–∞

    double b0 = (1.0 - cs) * 0.5;
    double b1 = 1.0 - cs;
    double b2 = b0;
    double a0 = 1.0 + alpha;
    double a1 = -2.0 * cs;
    double a2 = 1.0 - alpha;

    f->b0 = b0 / a0;
    f->b1 = b1 / a0;
    f->b2 = b2 / a0;
    f->a1 = a1 / a0;
    f->a2 = a2 / a0;
    f->x1 = f->x2 = f->y1 = f->y2 = 0.0;
}

double biquad_process(biquad_filter_t* f, double x) {
    double y = f->b0 * x + f->b1 * f->x1 + f->b2 * f->x2
               - f->a1 * f->y1 - f->a2 * f->y2;
    f->x2 = f->x1; f->x1 = x;
    f->y2 = f->y1; f->y1 = y;
    return y;
}
```

> –î–ª—è –ø–æ–ª–æ—Å–æ–≤–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞ –∫–æ–º–±–∏–Ω–∏—Ä—É—é—Ç—Å—è HPF –∏ LPF –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä—è–º–∞—è —Ñ–æ—Ä–º—É–ª–∞ –ø–æ–ª–æ—Å–æ–≤–æ–≥–æ –±–∏–∫–≤–∞–¥–∞.

---

## 4. –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è

### 4.1. –î–∏—Å–∫—Ä–µ—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –•–∞—Ä—Ç–ª–∏ (DHT)

–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:

\[
H[k] = \sum_{n=0}^{N-1} x[n] \cdot \operatorname{cas}\left( \frac{2\pi kn}{N} \right), \quad \operatorname{cas}(\theta) = \cos\theta + \sin\theta
\]

–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ: –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ, –æ–±—Ä–∞—Ç–∏–º–æ–µ, —ç–Ω–µ—Ä–≥–æ—Å–±–µ—Ä–µ–≥–∞—é—â–µ–µ.

#### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

```c
void dht(const double* input, double* output, size_t N) {
    const double two_pi = 2.0 * M_PI;
    for (size_t k = 0; k < N; ++k) {
        double sum = 0.0;
        for (size_t n = 0; n < N; ++n) {
            double angle = two_pi * (double)(k * n) / (double)N;
            sum += input[n] * (cos(angle) + sin(angle));
        }
        output[k] = sum;
    }
}
```

> **–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ**: \( O(N^2) \). –î–ª—è \( N > 512 \) –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å FHT –∏–ª–∏ FFT.

---

### 4.2. –ë—ã—Å—Ç—Ä–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –§—É—Ä—å–µ (FFT) ‚Äî Radix-2, in-place

–•–æ—Ç—è DHT —Ç–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª–µ–Ω, **FFT** –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª–µ–Ω –∏–∑-–∑–∞ –∑—Ä–µ–ª–æ—Å—Ç–∏ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏.

#### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è (–±–∞–∑–æ–≤–∞—è, –¥–ª—è —á—ë—Ç–Ω—ã—Ö N)

```c
// bit-reversal permutation
static void bit_reverse(double* x, size_t N) {
    for (size_t i = 0, j = 0; i < N; ++i) {
        if (j > i) {
            double tmp_real = x[2*i];   x[2*i] = x[2*j];   x[2*j] = tmp_real;
            double tmp_imag = x[2*i+1]; x[2*i+1] = x[2*j+1]; x[2*j+1] = tmp_imag;
        }
        size_t m = N >> 1;
        while (m >= 1 && j >= m) { j -= m; m >>= 1; }
        j += m;
    }
}

void fft_radix2(double* x, size_t N) {
    // x: –º–∞—Å—Å–∏–≤ –¥–ª–∏–Ω—ã 2*N: [Re0, Im0, Re1, Im1, ...]
    bit_reverse(x, N);
    for (size_t L = 2; L <= N; L <<= 1) {
        size_t L2 = L >> 1;
        double theta = -2.0 * M_PI / (double)L;
        double ur = 1.0, ui = 0.0;
        double wr = cos(theta), wi = sin(theta);
        for (size_t j = 0; j < L2; ++j) {
            for (size_t i = j; i < N; i += L) {
                size_t i1 = i + L2;
                double t_r = ur * x[2*i1] - ui * x[2*i1 + 1];
                double t_i = ur * x[2*i1 + 1] + ui * x[2*i1];
                x[2*i1]     = x[2*i] - t_r;
                x[2*i1 + 1] = x[2*i + 1] - t_i;
                x[2*i]     += t_r;
                x[2*i + 1] += t_i;
            }
            double tmp = ur * wr - ui * wi;
            ui = ur * wi + ui * wr;
            ur = tmp;
        }
    }
}
```

> **–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ**: –î–ª—è –≤–µ—â–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é (real FFT), –Ω–æ –¥–ª—è –æ–±—â–Ω–æ—Å—Ç–∏ –ø—Ä–∏–≤–µ–¥–µ–Ω–∞ –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è.

---

## 5. –ü–∞—Ä–∞–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑: –º–µ—Ç–æ–¥ –ü—Ä–æ–Ω–∏ (Prony)

### 5.1. –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å

–°–∏–≥–Ω–∞–ª –º–æ–¥–µ–ª–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫ —Å—É–º–º–∞ –∑–∞—Ç—É—Ö–∞—é—â–∏—Ö –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã—Ö —ç–∫—Å–ø–æ–Ω–µ–Ω—Ç:

\[
x[n] = \sum_{k=1}^{p} A_k e^{(\sigma_k + j\omega_k) n T}
\]

–¶–µ–ª—å ‚Äî –Ω–∞–π—Ç–∏ \( \omega_k \) (—Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ —á–∞—Å—Ç–æ—Ç—ã) –∏ \( \sigma_k \) (–¥–µ–∫—Ä–µ–º–µ–Ω—Ç—ã).

### 5.2. –ê–ª–≥–æ—Ä–∏—Ç–º

1. –†–µ—à–∏—Ç—å —Å–∏—Å—Ç–µ–º—É \( \mathbf{X} \mathbf{a} = -\mathbf{x} \), –≥–¥–µ \( \mathbf{X} \) ‚Äî –∞–≤—Ç–æ–∫–æ—Ä—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞.
2. –ù–∞–π—Ç–∏ –∫–æ—Ä–Ω–∏ –ø–æ–ª–∏–Ω–æ–º–∞ \( P(z) = 1 + a_1 z^{-1} + \dots + a_p z^{-p} \).
3. –ò–∑–≤–ª–µ—á—å —á–∞—Å—Ç–æ—Ç—ã: \( \omega_k = \arg(z_k) / T \).

#### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è, –¥–ª—è –º–∞–ª–æ–≥–æ p)

```c
// prony.c
#include <math.h>
#include <string.h>

// –†–µ—à–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –º–µ—Ç–æ–¥–æ–º –Ω–∞–∏–º–µ–Ω—å—à–∏—Ö –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ (–Ω–æ—Ä–º–∞–ª—å–Ω—ã–µ —É—Ä–∞–≤–Ω–µ–Ω–∏—è)
static void solve_least_squares(const double* X, const double* y, double* a, size_t rows, size_t cols) {
    // X: rows x cols, y: rows, a: cols
    // –§–æ—Ä–º–∏—Ä—É–µ–º A = X^T X, b = X^T y
    double A[cols * cols];
    double b[cols];
    memset(A, 0, sizeof(A));
    memset(b, 0, sizeof(b));

    for (size_t i = 0; i < rows; ++i) {
        for (size_t j = 0; j < cols; ++j) {
            b[j] += X[i * cols + j] * y[i];
            for (size_t k = 0; k < cols; ++k) {
                A[j * cols + k] += X[i * cols + j] * X[i * cols + k];
            }
        }
    }

    // –†–µ—à–∞–µ–º A a = b –º–µ—Ç–æ–¥–æ–º –ì–∞—É—Å—Å–∞ (—É–ø—Ä–æ—â—ë–Ω–Ω–æ)
    // ... (—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –ì–∞—É—Å—Å–∞ –æ–ø—É—â–µ–Ω–∞ –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏; –≤ production ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å QR –∏–ª–∏ SVD)
}

int prony_estimate_frequencies(const double* x, size_t N, size_t p,
                               double fs, double* frequencies, double* damping) {
    if (p >= N) return -1;

    // –§–æ—Ä–º–∏—Ä—É–µ–º –º–∞—Ç—Ä–∏—Ü—É X (—Ä–∞–∑–º–µ—Ä (N-p) x p)
    double* X = (double*)malloc((N - p) * p * sizeof(double));
    double* y = (double*)malloc((N - p) * sizeof(double));
    for (size_t i = 0; i < N - p; ++i) {
        for (size_t j = 0; j < p; ++j) {
            X[i * p + j] = x[i + p - 1 - j]; // –æ–±—Ä–∞—Ç–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫
        }
        y[i] = -x[i + p];
    }

    double* a = (double*)calloc(p, sizeof(double));
    solve_least_squares(X, y, a, N - p, p);

    // –¢–µ–ø–µ—Ä—å –Ω–∞—Ö–æ–¥–∏–º –∫–æ—Ä–Ω–∏ –ø–æ–ª–∏–Ω–æ–º–∞: z^p + a[0] z^{p-1} + ... + a[p-1] = 0
    // –≠—Ç–æ —Ç—Ä–µ–±—É–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ–∏—Å–∫–∞ –∫–æ—Ä–Ω–µ–π –ø–æ–ª–∏–Ω–æ–º–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –º–µ—Ç–æ–¥ –î–∂–µ–Ω–∫–∏–Ω—Å–∞-–¢—Ä–∞—É–±–∞)
    // –í —Ä–∞–º–∫–∞—Ö –¥–æ–∫—É–º–µ–Ω—Ç–∞ ‚Äî –∑–∞–≥–ª—É—à–∫–∞:
    // –ü—Ä–µ–¥–ø–æ–ª–æ–∂–∏–º, —á—Ç–æ –∫–æ—Ä–Ω–∏ —É–∂–µ –Ω–∞–π–¥–µ–Ω—ã –∫–∞–∫ complex_roots[0..p-1]

    // –ü—Ä–∏–º–µ—Ä –¥–ª—è –æ–¥–Ω–æ–≥–æ –∫–æ—Ä–Ω—è (–¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è):
    // double r = sqrt(creal*creal + cimag*cimag);
    // double theta = atan2(cimag, creal);
    // frequencies[0] = theta * fs / (2*M_PI);
    // damping[0] = log(r) * fs;

    free(X); free(y); free(a);
    return 0; // —É—Å–ø–µ—Ö (–≤ —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ ‚Äî —á–∏—Å–ª–æ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –º–æ–¥)
}
```

> **–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –î–ª—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å **TLS-ESPRIT** –∏–ª–∏ **Stochastic Subspace Identification (SSI)** –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.

---

## 6. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è SSI (Stochastic Subspace Identification)

### 6.1. –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ Hankel-–º–∞—Ç—Ä–∏—Ü—ã

–î–ª—è —Å–∏–≥–Ω–∞–ª–∞ \( y[0], \dots, y[N-1] \):

\[
\mathbf{H} = \begin{bmatrix}
y[0] & y[1] & \cdots & y[j-1] \\
y[1] & y[2] & \cdots & y[j] \\
\vdots & \vdots & \ddots & \vdots \\
y[i-1] & y[i] & \cdots & y[i+j-2]
\end{bmatrix}
\]

–≥–¥–µ \( i + j - 1 = N \).

#### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

```c
size_t build_hankel_matrix(const double* signal, size_t N, size_t num_rows, double* hankel) {
    if (num_rows == 0 || num_rows > N) return 0;
    size_t num_cols = N - num_rows + 1;
    for (size_t i = 0; i < num_rows; ++i) {
        memcpy(&hankel[i * num_cols], &signal[i], num_cols * sizeof(double));
    }
    return num_cols;
}
```

> –≠—Ç–∞ –º–∞—Ç—Ä–∏—Ü–∞ –ø–æ–¥–∞—ë—Ç—Å—è –Ω–∞ –≤—Ö–æ–¥ SVD –≤ —Ä–∞–º–∫–∞—Ö SSI.

---

## 7. –ó–∞–∫–ª—é—á–µ–Ω–∏–µ –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

| –≠—Ç–∞–ø | –ú–µ—Ç–æ–¥ | –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ |
|------|-------|-----------|
| –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ | –ê—Ñ—Ñ–∏–Ω–Ω–∞—è –º–æ–¥–µ–ª—å | –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ |
| –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è | HPF + Butterworth BP | –ü–æ–¥–∞–≤–ª–µ–Ω–∏–µ –¥—Ä–µ–π—Ñ–∞ –∏ —à—É–º–∞ |
| –°–ø–µ–∫—Ç—Ä | FFT / DHT | –ë—ã—Å—Ç—Ä–∞—è –æ—Ü–µ–Ω–∫–∞ —Å–ø–µ–∫—Ç—Ä–∞ |
| –ú–æ–¥–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ | Prony / SSI / ESPRIT | –¢–æ—á–Ω—ã–π –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç |
| –¢—Ä–µ–∫–∏–Ω–≥ | –§–∏–ª—å—Ç—Ä –ö–∞–ª–º–∞–Ω–∞ | –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤–æ –≤—Ä–µ–º–µ–Ω–∏ |

### –¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏:
- –ù–∞ **–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–µ**: HPF, –∫–∞–ª–∏–±—Ä–æ–≤–∫–∞, –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è.
- –ù–∞ **—Å–µ—Ä–≤–µ—Ä–µ**: SSI, –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è, –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è.

### –î–∞–ª—å–Ω–µ–π—à–∏–µ —à–∞–≥–∏:
1. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å **SVD –Ω–∞ —á–∏—Å—Ç–æ–º C** (Golub-Reinsch).
2. –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å **–º—É–ª—å—Ç–∏–¥–∞—Ç—á–∏–∫–æ–≤—É—é —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é**.
3. –î–æ–±–∞–≤–∏—Ç—å **—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–Ω—É—é –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—é** –º–æ–¥–∞–ª—å–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç.

---

**–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ**: –í—Å–µ –∑–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã (`*.h`) –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (`*.c`) —Å–æ–≤–º–µ—Å—Ç–∏–º—ã —Å **C99**, –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ (–∫—Ä–æ–º–µ `prony.c` ‚Äî –µ–≥–æ –º–æ–∂–Ω–æ –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å –ø–æ–¥ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –±—É—Ñ–µ—Ä—ã), –∏ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω—ã —Å `-O2 -ffast-math` –¥–ª—è –≤—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã—Ö —Å–∏—Å—Ç–µ–º.

---

–ù–∏–∂–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω **—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –¥–æ–∫—É–º–µ–Ω—Ç** —Å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π —Ç—Ä—ë—Ö –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏–Ω–∂–µ–Ω–µ—Ä–Ω—ã—Ö —Å–æ–æ—Ä—É–∂–µ–Ω–∏–π:

1. **SVD –Ω–∞ —á–∏—Å—Ç–æ–º C (–∞–ª–≥–æ—Ä–∏—Ç–º Golub‚ÄìReinsch)**  
2. **–ú—É–ª—å—Ç–∏–¥–∞—Ç—á–∏–∫–æ–≤–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–∞ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–µ**  
3. **–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–Ω–∞—è –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç**

–í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –Ω–∞ **—á–∏—Å—Ç–æ–º C99**, –±–µ–∑ –≤–Ω–µ—à–Ω–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π (–∫—Ä–æ–º–µ `<math.h>`), —Å –ø–æ–ª–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π, —Ñ–æ—Ä–º—É–ª–∞–º–∏ –∏ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–º–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏.

---

# üìÑ **–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –¥–æ–∫—É–º–µ–Ω—Ç: –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –¥–ª—è —Å–∏—Å—Ç–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏–Ω–∂–µ–Ω–µ—Ä–Ω—ã—Ö –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π**

**–ê–≤—Ç–æ—Ä**: –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ AXIOMICA  
**–î–∞—Ç–∞**: 23 –æ–∫—Ç—è–±—Ä—è 2025 –≥.

---

## –ß–∞—Å—Ç—å 1. –°–∏–Ω–≥—É–ª—è—Ä–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ (SVD) ‚Äî –∞–ª–≥–æ—Ä–∏—Ç–º Golub‚ÄìReinsch

### 1.1. –¢–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ—Å–Ω–æ–≤—ã

–î–ª—è –º–∞—Ç—Ä–∏—Ü—ã \( A \in \mathbb{R}^{m \times n} \) (\( m \geq n \)) —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ:

\[
A = U \Sigma V^T
\]

–≥–¥–µ:
- \( U \in \mathbb{R}^{m \times m} \) ‚Äî –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è,
- \( V \in \mathbb{R}^{n \times n} \) ‚Äî –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è,
- \( \Sigma \in \mathbb{R}^{m \times n} \) ‚Äî –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–∞—è —Å —Å–∏–Ω–≥—É–ª—è—Ä–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏ \( \sigma_1 \geq \sigma_2 \geq \dots \geq \sigma_n \geq 0 \).

–ê–ª–≥–æ—Ä–∏—Ç–º Golub‚ÄìReinsch:
1. –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ \( A \) –∫ **–¥–≤—É—Ö–¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Ñ–æ—Ä–º–µ** —Å –ø–æ–º–æ—â—å—é Householder-–æ—Ç—Ä–∞–∂–µ–Ω–∏–π.
2. –ò—Ç–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–µ **–¥–∏–∞–≥–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∏–µ** –¥–≤—É—Ö–¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π –º–∞—Ç—Ä–∏—Ü—ã –º–µ—Ç–æ–¥–æ–º QR —Å shift.

### 1.2. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ C99

> **–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ**: —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è \( m \geq n \), –±–µ–∑ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–≥–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø–∞–º—è—Ç–∏ (–≤—Å–µ –±—É—Ñ–µ—Ä—ã —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –∏–ª–∏ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –∏–∑–≤–Ω–µ).

```c
// svd.h
#ifndef SVD_H
#define SVD_H

#include <stddef.h>
#include <stdbool.h>

/**
 * @brief –í—ã—á–∏—Å–ª—è–µ—Ç —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã A (m x n, m >= n).
 *
 * @param A        –í—Ö–æ–¥–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ (—Ä–∞–∑–º–µ—Ä m*n), —Ö—Ä–∞–Ω–∏—Ç—Å—è –ø–æ —Å—Ç—Ä–æ–∫–∞–º.
 *                 –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–µ–≤—É—é —á–∞—Å—Ç—å U (m x n).
 * @param m        –ß–∏—Å–ª–æ —Å—Ç—Ä–æ–∫.
 * @param n        –ß–∏—Å–ª–æ —Å—Ç–æ–ª–±—Ü–æ–≤ (m >= n).
 * @param S        –í—ã—Ö–æ–¥: —Å–∏–Ω–≥—É–ª—è—Ä–Ω—ã–µ —á–∏—Å–ª–∞ (–¥–ª–∏–Ω–∞ n).
 * @param V        –í—ã—Ö–æ–¥: –ø—Ä–∞–≤–∞—è –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ (n x n).
 * @param work     –†–∞–±–æ—á–∏–π –±—É—Ñ–µ—Ä (–¥–ª–∏–Ω–∞ >= 4*n).
 * @return true –ø—Ä–∏ —É—Å–ø–µ—Ö–µ, false –ø—Ä–∏ –Ω–µ—Å—Ö–æ–¥—è—â–µ–π—Å—è –∏—Ç–µ—Ä–∞—Ü–∏–∏.
 *
 * @note –ê–ª–≥–æ—Ä–∏—Ç–º –æ—Å–Ω–æ–≤–∞–Ω –Ω–∞ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ Golub‚ÄìReinsch.
 *       –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –∏—Ç–µ—Ä–∞—Ü–∏–π: 50 –Ω–∞ —Å–∏–Ω–≥—É–ª—è—Ä–Ω–æ–µ —á–∏—Å–ª–æ.
 */
bool svd_decompose(double* A, size_t m, size_t n, double* S, double* V, double* work);

#endif // SVD_H
```

```c
// svd.c
#include "svd.h"
#include <math.h>
#include <string.h>

static const int MAX_ITER = 50;
static const double EPS = 1e-12;

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –∑–Ω–∞–∫ —Å –Ω—É–ª—ë–º –∫–∞–∫ +1
static double dsign(double a, double b) {
    return (b >= 0.0) ? fabs(a) : -fabs(a);
}

// –£–º–Ω–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –Ω–∞ Householder-–≤–µ–∫—Ç–æ—Ä —Å–ª–µ–≤–∞
static void apply_householder_left(double* A, size_t m, size_t n, size_t col,
                                   const double* v, double tau) {
    for (size_t j = 0; j < n; ++j) {
        double sum = 0.0;
        for (size_t i = col; i < m; ++i) {
            sum += v[i - col] * A[i * n + j];
        }
        for (size_t i = col; i < m; ++i) {
            A[i * n + j] -= tau * v[i - col] * sum;
        }
    }
}

// –£–º–Ω–æ–∂–µ–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –Ω–∞ Householder-–≤–µ–∫—Ç–æ—Ä —Å–ø—Ä–∞–≤–∞
static void apply_householder_right(double* A, size_t m, size_t n, size_t row,
                                    const double* v, double tau) {
    for (size_t i = 0; i < m; ++i) {
        double sum = 0.0;
        for (size_t j = row; j < n; ++j) {
            sum += A[i * n + j] * v[j - row];
        }
        for (size_t j = row; j < n; ++j) {
            A[i * n + j] -= tau * sum * v[j - row];
        }
    }
}

bool svd_decompose(double* A, size_t m, size_t n, double* S, double* V, double* work) {
    if (m < n) return false;

    double* e = work;          // –¥–ª–∏–Ω–∞ n
    double* tau_u = e + n;     // –¥–ª–∏–Ω–∞ n
    double* tau_v = tau_u + n; // –¥–ª–∏–Ω–∞ n-1
    double* temp = tau_v + n - 1; // –¥–ª–∏–Ω–∞ n

    // –®–∞–≥ 1: –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ –≤–µ—Ä—Ö–Ω–µ–π –¥–≤—É—Ö–¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Ñ–æ—Ä–º–µ
    for (size_t k = 0; k < n; ++k) {
        // Householder –¥–ª—è —Å—Ç–æ–ª–±—Ü–∞ k
        double norm = 0.0;
        for (size_t i = k; i < m; ++i) {
            norm += A[i * n + k] * A[i * n + k];
        }
        double x = A[k * n + k];
        double rho = -dsign(sqrt(norm), x);
        double inv_rho = (fabs(rho) > EPS) ? 1.0 / rho : 0.0;
        A[k * n + k] = x - rho;
        S[k] = rho;
        tau_u[k] = (rho - x) * inv_rho;

        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–ª–µ–≤–∞
        apply_householder_left(A, m, n, k, &A[k * n + k], tau_u[k]);

        if (k < n - 1) {
            // Householder –¥–ª—è —Å—Ç—Ä–æ–∫–∏ k (–ø—Ä–∞–≤–∞—è —á–∞—Å—Ç—å)
            norm = 0.0;
            for (size_t j = k + 1; j < n; ++j) {
                norm += A[k * n + j] * A[k * n + j];
            }
            x = A[k * n + k + 1];
            rho = -dsign(sqrt(norm), x);
            inv_rho = (fabs(rho) > EPS) ? 1.0 / rho : 0.0;
            A[k * n + k + 1] = x - rho;
            e[k] = rho;
            tau_v[k] = (rho - x) * inv_rho;

            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–ø—Ä–∞–≤–∞
            apply_householder_right(A, m, n, k + 1, &A[k * n + k + 1], tau_v[k]);
        }
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è V –∫–∞–∫ I
    memset(V, 0, n * n * sizeof(double));
    for (size_t i = 0; i < n; ++i) V[i * n + i] = 1.0;

    // –®–∞–≥ 2: QR-–∏—Ç–µ—Ä–∞—Ü–∏–∏ —Å shift –¥–ª—è –¥–∏–∞–≥–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏
    size_t iter = 0;
    size_t k = n - 1;
    while (k >= 1) {
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –Ω–∏–∂–Ω–µ–π —Å—É–±–¥–∏–∞–≥–æ–Ω–∞–ª–∏
        if (fabs(e[k - 1]) <= EPS * (fabs(S[k - 1]) + fabs(S[k]))) {
            e[k - 1] = 0.0;
            k--;
            continue;
        }

        if (iter >= MAX_ITER) return false;
        iter++;

        // Wilkinson shift
        double dk = S[k];
        double dk1 = S[k - 1];
        double ek1 = e[k - 1];
        double mu = 0.0;
        if (iter % 2 == 0) {
            double delta = (dk1 * dk1 - dk * dk + ek1 * ek1) / (2.0 * ek1 * dk);
            double s = dsign(1.0, delta);
            mu = dk * dk / (delta + s * sqrt(delta * delta + dk * dk));
        }

        // QR-—à–∞–≥ —Å shift
        double x = S[0] * S[0] - mu;
        double y = S[0] * e[0];
        for (size_t i = 0; i < k; ++i) {
            double c, s;
            double r = hypot(x, y);
            if (r == 0.0) {
                c = 1.0; s = 0.0;
            } else {
                c = x / r;
                s = y / r;
            }

            // –í—Ä–∞—â–µ–Ω–∏–µ Givens —Å–ª–µ–≤–∞
            if (i > 0) e[i - 1] = r;
            x = c * S[i] + s * e[i];
            e[i] = c * e[i] - s * S[i];
            y = s * S[i + 1];
            S[i + 1] = c * S[i + 1];

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ V
            for (size_t j = 0; j < n; ++j) {
                double t1 = V[j * n + i];
                double t2 = V[j * n + i + 1];
                V[j * n + i]     = c * t1 + s * t2;
                V[j * n + i + 1] = c * t2 - s * t1;
            }

            // –í—Ä–∞—â–µ–Ω–∏–µ Givens —Å–ø—Ä–∞–≤–∞
            r = hypot(x, y);
            if (r == 0.0) {
                c = 1.0; s = 0.0;
            } else {
                c = x / r;
                s = y / r;
            }
            S[i] = r;
            x = c * e[i] + s * S[i + 1];
            S[i + 1] = c * S[i + 1] - s * e[i];
            if (i < k - 1) {
                y = s * e[i + 1];
                e[i + 1] = c * e[i + 1];
            }
        }
    }

    // –£–ø–æ—Ä—è–¥–æ—á–∏–≤–∞–Ω–∏–µ –ø–æ —É–±—ã–≤–∞–Ω–∏—é (–ø—Ä–æ—Å—Ç–æ–π bubble sort –¥–ª—è –º–∞–ª—ã—Ö n)
    for (size_t i = 0; i < n; ++i) {
        for (size_t j = i + 1; j < n; ++j) {
            if (S[j] > S[i]) {
                double t = S[i]; S[i] = S[j]; S[j] = t;
                for (size_t r = 0; r < m; ++r) {
                    t = A[r * n + i]; A[r * n + i] = A[r * n + j]; A[r * n + j] = t;
                }
                for (size_t r = 0; r < n; ++r) {
                    t = V[r * n + i]; V[r * n + i] = V[r * n + j]; V[r * n + j] = t;
                }
            }
        }
    }

    return true;
}
```

> **–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ**: –≠—Ç–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –ø–æ–¥ **–º–∞–ª—ã–µ –º–∞—Ç—Ä–∏—Ü—ã** (n ‚â§ 20), —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω—ã–µ –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞.

---

## –ß–∞—Å—Ç—å 2. –ú—É–ª—å—Ç–∏–¥–∞—Ç—á–∏–∫–æ–≤–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è

### 2.1. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

- –í—Å–µ –¥–∞—Ç—á–∏–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –∫ –æ–¥–Ω–æ–º—É –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä—É.
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è **–∞–ø–ø–∞—Ä–∞—Ç–Ω—ã–π —Ç—Ä–∏–≥–≥–µ—Ä** (–Ω–∞–ø—Ä–∏–º–µ—Ä, DRDY –æ—Ç –∞–∫—Å–µ–ª–µ—Ä–æ–º–µ—Ç—Ä–∞) –∏–ª–∏ **–∂—ë—Å—Ç–∫–æ–µ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ**.
- –í—Ä–µ–º–µ–Ω–Ω–∞—è –º–µ—Ç–∫–∞ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è **–ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è –≤—Å–µ—Ö –¥–∞—Ç—á–∏–∫–æ–≤**.

### 2.2. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è

```c
// sync_acquisition.h
#ifndef SYNC_ACQUISITION_H
#define SYNC_ACQUISITION_H

#include "sensor_types.h"
#include <stdint.h>
#include <stdbool.h>

#define MAX_SENSORS_PER_NODE 8

typedef struct {
    sensor_interface_t* sensors[MAX_SENSORS_PER_NODE];
    uint8_t count;
    uint64_t (*get_time_us)(void); // –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–∑–∞–≤–∏—Å–∏–º–∞—è —Ñ—É–Ω–∫—Ü–∏—è
} sync_node_t;

/**
 * @brief –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –¥–∞—Ç—á–∏–∫–∞ –≤ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —É–∑–ª–µ.
 */
bool sync_node_add_sensor(sync_node_t* node, sensor_interface_t* s);

/**
 * @brief –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —á—Ç–µ–Ω–∏–µ —Å–æ –≤—Å–µ—Ö –¥–∞—Ç—á–∏–∫–æ–≤.
 * @param node –£–∑–µ–ª.
 * @param batch –í—ã—Ö–æ–¥–Ω–æ–π –º–∞—Å—Å–∏–≤ —Å—ç–º–ø–ª–æ–≤ (–¥–æ–ª–∂–µ–Ω –≤–º–µ—â–∞—Ç—å node->count —ç–ª–µ–º–µ–Ω—Ç–æ–≤).
 * @param out_count –§–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ —á–∏—Å–ª–æ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö —Å—ç–º–ø–ª–æ–≤.
 * @return true, –µ—Å–ª–∏ –≤—Å–µ –¥–∞—Ç—á–∏–∫–∏ –ø—Ä–æ—á–∏—Ç–∞–Ω—ã —É—Å–ø–µ—à–Ω–æ.
 */
bool sync_node_acquire(sync_node_t* node, synchronized_sample_t* batch, size_t* out_count);

#endif // SYNC_ACQUISITION_H
```

```c
// sync_acquisition.c
#include "sync_acquisition.h"
#include <string.h>

bool sync_node_add_sensor(sync_node_t* node, sensor_interface_t* s) {
    if (node->count >= MAX_SENSORS_PER_NODE) return false;
    node->sensors[node->count++] = s;
    return true;
}

bool sync_node_acquire(sync_node_t* node, synchronized_sample_t* batch, size_t* out_count) {
    vector3d_t raw_values[MAX_SENSORS_PER_NODE];
    bool success = true;

    // –≠—Ç–∞–ø 1: —á—Ç–µ–Ω–∏–µ –≤—Å–µ—Ö –¥–∞—Ç—á–∏–∫–æ–≤
    for (uint8_t i = 0; i < node->count; ++i) {
        if (!node->sensors[i]->read(&raw_values[i])) {
            success = false;
        }
    }

    // –≠—Ç–∞–ø 2: –µ–¥–∏–Ω–∞—è –≤—Ä–µ–º–µ–Ω–Ω–∞—è –º–µ—Ç–∫–∞
    uint64_t ts = node->get_time_us();

    // –≠—Ç–∞–ø 3: —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã—Ö–æ–¥–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞
    *out_count = 0;
    for (uint8_t i = 0; i < node->count; ++i) {
        batch[i].timestamp_us = ts;
        batch[i].sensor_id = i;
        batch[i].type = node->sensors[i]->type;
        batch[i].value = raw_values[i];
        (*out_count)++;
    }

    return success;
}
```

> **–í–∞–∂–Ω–æ**: –î–ª—è MEMS-–¥–∞—Ç—á–∏–∫–æ–≤ —Å DRDY –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –ø–æ —Ñ—Ä–æ–Ω—Ç—É DRDY –∏ —á—Ç–µ–Ω–∏–µ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ.

---

## –ß–∞—Å—Ç—å 3. –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–Ω–∞—è –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç

### 3.1. –ú–æ–¥–µ–ª—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

–°–æ–±—Å—Ç–≤–µ–Ω–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ \( f_i \) –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã \( T \) –ª–∏–Ω–µ–π–Ω–æ –≤ –ø–µ—Ä–≤–æ–º –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–∏:

\[
f_i(T) = f_{i,0} + \alpha_i (T - T_0)
\]

–≥–¥–µ:
- \( f_{i,0} \) ‚Äî —á–∞—Å—Ç–æ—Ç–∞ –ø—Ä–∏ –æ–ø–æ—Ä–Ω–æ–π —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–µ \( T_0 \),
- \( \alpha_i \) ‚Äî —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç (–ì—Ü/¬∞C).

### 3.2. –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏–∏

```c
// thermal_compensation.h
#ifndef THERMAL_COMPENSATION_H
#define THERMAL_COMPENSATION_H

#include <stddef.h>

typedef struct {
    double f0;        // —á–∞—Å—Ç–æ—Ç–∞ –ø—Ä–∏ T0
    double alpha;     // –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç (–ì—Ü/¬∞C)
    double T0;        // –æ–ø–æ—Ä–Ω–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ (¬∞C)
} mode_thermal_model_t;

/**
 * @brief –ö–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–π —á–∞—Å—Ç–æ—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–π —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã.
 * @param model –ú–æ–¥–µ–ª—å –º–æ–¥—ã.
 * @param T_current –¢–µ–∫—É—â–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ (¬∞C).
 * @return –°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ (–ì—Ü).
 */
double compensate_frequency(const mode_thermal_model_t* model, double T_current);

/**
 * @brief –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–Ω–æ–π –º–æ–¥–µ–ª–∏ –ø–æ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–º –¥–∞–Ω–Ω—ã–º.
 * @param T –ú–∞—Å—Å–∏–≤ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä (–¥–ª–∏–Ω–∞ N).
 * @param f –ú–∞—Å—Å–∏–≤ –∏–∑–º–µ—Ä–µ–Ω–Ω—ã—Ö —á–∞—Å—Ç–æ—Ç (–¥–ª–∏–Ω–∞ N).
 * @param N –ß–∏—Å–ª–æ —Ç–æ—á–µ–∫.
 * @param model –í—ã—Ö–æ–¥–Ω–∞—è –º–æ–¥–µ–ª—å.
 * @return true –ø—Ä–∏ —É—Å–ø–µ—Ö–µ.
 */
bool calibrate_thermal_model(const double* T, const double* f, size_t N, mode_thermal_model_t* model);

#endif // THERMAL_COMPENSATION_H
```

```c
// thermal_compensation.c
#include "thermal_compensation.h"
#include <math.h>

double compensate_frequency(const mode_thermal_model_t* model, double T_current) {
    return model->f0 + model->alpha * (T_current - model->f0);
}

bool calibrate_thermal_model(const double* T, const double* f, size_t N, mode_thermal_model_t* model) {
    if (N < 2) return false;

    // –õ–∏–Ω–µ–π–Ω–∞—è —Ä–µ–≥—Ä–µ—Å—Å–∏—è: f = a * T + b
    double sum_T = 0.0, sum_f = 0.0, sum_Tf = 0.0, sum_T2 = 0.0;
    for (size_t i = 0; i < N; ++i) {
        sum_T += T[i];
        sum_f += f[i];
        sum_Tf += T[i] * f[i];
        sum_T2 += T[i] * T[i];
    }

    double denom = N * sum_T2 - sum_T * sum_T;
    if (fabs(denom) < 1e-12) return false;

    double a = (N * sum_Tf - sum_T * sum_f) / denom;
    double b = (sum_f - a * sum_T) / N;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–æ–¥–µ–ª—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ T0 = —Å—Ä–µ–¥–Ω–µ–π —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã
    double T0 = sum_T / N;
    model->T0 = T0;
    model->alpha = a;
    model->f0 = a * T0 + b;

    return true;
}
```

> **–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ**: –ù–∞ —Å–µ—Ä–≤–µ—Ä–µ –ø–æ—Å–ª–µ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∫–∞–∂–¥–∞—è –≤—ã–¥–µ–ª–µ–Ω–Ω–∞—è —á–∞—Å—Ç–æ—Ç–∞ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ—Ç—Å—è –ø–æ —Ç–µ–∫—É—â–µ–π —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–µ –≤ —Ç–æ—á–∫–µ –∏–∑–º–µ—Ä–µ–Ω–∏—è.

---

## –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

–ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –æ–±—Ä–∞–∑—É—é—Ç **–ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–µ —è–¥—Ä–æ** –¥–ª—è:

- **–¢–æ—á–Ω–æ–π –ª–æ–∫–∞–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏** –¥–∞–Ω–Ω—ã—Ö —Å —Ä–∞–∑–Ω–æ—Ä–æ–¥–Ω—ã—Ö –¥–∞—Ç—á–∏–∫–æ–≤,
- **–†–æ–±–∞—Å—Ç–Ω–æ–≥–æ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞** –Ω–∞ –æ—Å–Ω–æ–≤–µ SVD,
- **–§–∏–∑–∏—á–µ—Å–∫–∏ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–Ω–æ–π –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏–∏** –≤–Ω–µ—à–Ω–∏—Ö —Ñ–∞–∫—Ç–æ—Ä–æ–≤.

–í—Å–µ –º–æ–¥—É–ª–∏:
- —Å–æ–≤–º–µ—Å—Ç–∏–º—ã —Å **C99**,
- –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç **–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏** (–∫—Ä–æ–º–µ —è–≤–Ω–æ –æ–≥–æ–≤–æ—Ä—ë–Ω–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤),
- –ø—Ä–∏–≥–æ–¥–Ω—ã –¥–ª—è **–≤—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã—Ö —Å–∏—Å—Ç–µ–º** –∏ **—Å–µ—Ä–≤–µ—Ä–Ω–æ–π –∞–Ω–∞–ª–∏—Ç–∏–∫–∏**.

–î–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ –≤ –≤–∞—à—É —Å–∏—Å—Ç–µ–º—É AXIOMICA —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è:
1. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `sync_acquisition` –Ω–∞ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–µ,
2. –ü–µ—Ä–µ–¥–∞–≤–∞—Ç—å —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–µ—Ä–≤–µ—Ä,
3. –í—ã–ø–æ–ª–Ω—è—Ç—å SVD + SSI + thermal compensation –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.
